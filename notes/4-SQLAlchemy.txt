----------------------------------- SQLAlchemy -----------------------------------
Use SQLAlchemy to create proper databases
It is similar to SQL but has benefits such as:
    ORM
    Handle creating tables
    Database migration easier
    Code is shorter and cleaner

Add:
    sqlalchemy
    flask-sqlalchemy 
To our requirements.txt
Then run
    pip install -r requirements.txt 
This will run again in Dockerfile 

----------------------------------- SQLAlchemy Model -----------------------------------
Go to db.py and enter:
    from flask_sqlalchemy import SQLAlchemy
    db = SQLAlchemy()
This creates an SQLAlchemy object which can be linked to our flask app later

Create a models folder and create:
    item.py 
Inside this item.py we create our item models

    from db import db
    class ItemModel(db.Model):
        __tablename__ = "items" 
        id = db.Column(db.Integer, primary_key=True)
        name = db.Column(db.String(80), unique=True, nullable=False)
        price = db.Column(db.Float(precision=2), unique=False, nullable=False)
        store_id = db.Column(db.Integer, unique=False, nullable=False)

Tells SQLAlchemy we want table items defining all models of class
Any time we add new model, id will increment automatically
In the name column:
    We limit the character count to 80
    It must have a unique name
    It can not be an empty string

For our store model, create a new Store.py file in the model directory:

    from db import db 
    class StoreModel(db.Model):
        __tablename__ = "stores"
        id = db.Column(db.Integer, primary_key=True)
        name = db.Column(db.String(80), unique=True, nullable=False)

The id value here, will map to the store_id value in models.items.py 

----------------------------------- One to Many -----------------------------------
Every item has a store_id, therefore each item has a store associated with it
However every store can be associated with several items.
We need to tell SQLAlchemy that store_id is a foreign ey, which we do by:

        store_id = db.Column(db.Integer, db.ForeignKey("stores.id"), unique = False, nullable = False)

We use the tablename (stores) and the column (id) therefore stores.id 

We can also grab a store model object which has the store_id

        store = db.relationship("StoreModel", back_populates="items")

SQLAlchemy knows the stores table is used by the StoreModel class. 
We can define a relationship with the specific StoreModel object whos id matched store_id 
back_populates="items" is used so that each StoreModel class can see items that are related to it
This is done by adding the following in the StoreModels class:

        items = db.relationship("ItemModel", back_populates="store", lazy="dynamic")

Where lazy="dynamic" means the items defined in this StoreModel class are not going to be fetched from db until we tell it to. 

Create a __init__.py file in the models directory
It is used to iport our models more easily 

    from models.store import StoreModel
    from models.item import ItemModel 

Make some ammends to the schemas.py file.
This is because when we create an item or store model there will be a relationshp to something else (a nested object)
Rename ItemSchema to PlainItemSchema, and remove store_id 
this will be an ItemSchema that focuses on the item, it will not deal with stores
We will use it when we want to include a nested item within a store, but don't want store info in the item itself. 

We also rename StoreSchema to PlainStoreSchema 

Then add a ItemSchema:

    class ItemSchema(PlainItemSchema):
        store_id = fields.Int(required=True, load_only=True)
        store = fields.Nested(PlainStoreSchema(), dump_only=True)

ItemSchema will inherit all the fields from PlainItemSchema, but add a new column
Now we can use ItemSchema we can pass in store_id when receiving data from client
We also have a nested Store, which is only used when returning data to the client 

Also create a StoreSchema that inherits from the PlainStoreSchema.

    class StoreSchema(PlainStoreSchema):
        items = fields.List(fiels.Nested(PlainItemSchema()), dump_only=True)

----------------------------------- Configure SQLAlchemy -----------------------------------
Go to app.py add

    from db import db 
    import models 

With this we now have easy access to our models, for example we could say 

    models.ItemModel 

To easily access our models. 
Our models need to be imported before configuring SQLAlchemy

We want to create a function in app.py to create, set up and configure the flask app 
    def create_app():
We dump all info in there from:
        app = Flask(__name)
to
        api.register_blueprint(StoreBlueprint)
and we add 
        return app 
We also need to setup our database URL in this function
        app.config["SQLALCHEMY_DATABASE_URI"] = os.getenv("DATABASE_URL", "sqlite:///data.db")
This creates a file called data.db where our data is stored 
REMEMBER to import os in app.py 
It will first try and access the DATABASE_URL environment variable, and if that fails it will try and acces to sqlite environment variable  
Give a parameter to your create_app function
    def create_app(db_url=None)
We do this so that if there is a specific db url we want to connect to so now ammend:
        app.config["SQLALCHEMY_DATABASE_URI"] = db.url or os.getenv("DATABASE_URL", sqlite:///data.db")
Now add another config line 
        app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False 
Now add:
        db.init_app(app)
Which connects the flask app to SQLAlchemy 
Now add:
        with app.app_context():
            db.create_all()
So now when we start the app before the first request this creates all tables in our database. If they already exists it wont create them 

Run 
    flask run 
In your terminal, and under instance repo you will see data.db 

----------------------------------- Insert Data Using SQLAlchemy -----------------------------------
If we go to our resources/item.py file we see our validations.

This is null and void as in our models/item.py we state: 

    class ItemModel(db.Model):
        __tablename__ = "items"

        id = db.Column(db.Integer, primary_key=True)
        name = db.Column(db.String(80), unique=True, nullable=False)
        price = db.Column(db.Float(precision=2), unique=False, nullable=False)
        store_id = db.Column(db.Integer, db.ForeignKey("stores.id"), unique=False, nullable=False)
        store = db.relationship("StoreModel", back_populates="items")

This sorts our uniqueness and dat-type of the item resource, so we don't really need that part in resources/item.py 
We can therefore completely refactor our POST request for new items:
    @blp.arguments(ItemSchema)
    @blp.response(201, ItemSchema)
    def post(self, item_data):
        item = ItemModel(**item_data)

        try:
            db.session.add(item)
            db.session.commit()
        except SQLAlchemyError:
            abort(500, message="An error occured when inserting item")
        return item

**item_data turns our paramter item_data into key-word arguments, so any data received from client is turned to a kwargs
All columns can be passed as kwargs except those with default args (like id)
Therefore **item_data should include name, price and store_id
Import ItemModel from models at the top of this file. 
Import db from db 
Import SQLAlechmyError from sqlalchemy.exc.exc 
Commiting saves to the db file

We can do the same with adding stores, however there is another except that can occur:
        except IntegrityError:
            abort(400, message="A store with this name already exists")
This is as our store name must be unique
(IntegrityError is also imported from sqlalchemy.exc)

----------------------------------- GET Models of 404 -----------------------------------
Use model classes to interact and rereive data.
In the Item => get function we say:

    @blp.route("/item/<string:item_id>")
    class Item(MethodView):
        @blp.response(200, ItemSchema)
        def get(self, item_id):
            item = ItemModel.query.get_or_404(item_id)
            return item

This retireves item from db using items primary key 
If no item with primary key in db it auto aborts with a 404 status-code. 

This works similar with the delete and put functions:
        def delete(self, item_id):
            item = ItemModel.query.get_or_404(item_id)
            raise NotImplementedError("Deleting an item is not implemented)

----------------------------------- Update Models -----------------------------------
We want to implement a idempotent request, meaning one or 10 requests should result in same state at the end
This ensures client can't mess up by sending more than one request 
This is what we use PUT requests

        item = ItemModel.query.get(item_id)
        if item:
            item.price = item_data["price"]
            item.name = item_data["name"]
        else:
            item = ItemModel(id=item_id, **item_data)
        db.session.add(item)
        db.session.commit()
        return item

This states that if item does exist we only need name and price to be passed
If it doesnt exist we need price, name and store_id to be passed which our API will handle
We need to go to our ItemUpdateSchema and add a store_id category like so:

    store_id = fields.Int()

As a PUT request is used to update or create an item by trying to update an item that doesnt exist, we ensure that nothing is created.
We do this as we do not pass in a store_id which is invalid on our models/item.oy file
May be best to create a PATCH request instead for efficiency.

Showing that it is not required, but if it isn't then we will receive an error due to it being labeled nullable=False in our models. 

We update the ItemUpdateSchema to reflect this by:

Remember to add and commit the new item

We don't use get_or_404  

----------------------------------- Retrieve All Models -----------------------------------
Simple, just enter 
    return ItemModel.query.all()
And do same for stores, this returns all items and stores
This is thanks to the many=all parameter.

----------------------------------- Delete Models -----------------------------------
To delete a model just put:
        item = ItemModel.query.get_or_404(item_id)
        db.session.delete(item)
        db.session.commit()
        return {"message": "Item deleted"}

----------------------------------- Cascades (Delete Models) -----------------------------------
Foreign Key constraints are not implemented
In this example that means we can create an item that with a store_id that doesnt exist
(This is with SQLAlchemy), PostgreSQL will not allow this

If we delete a store that has an item in, SQLAlchemy will not allow this. 
This is because the foreign_key is set to nullable equals false 
So we do the following; by deleting the store, the items are deleted too 
So we want to delete the children when we delete the parent
We use alter the models/store.py file with the following:

        items = db.relationship("ItemModel", back_populates="store", lazy="dynamic", cascade="all, delete, delete-orphan")

